const Product = require('../models/Product');
const catchAsync = require('../utils/catchAsync');
const AppError = require('../utils/AppError');
const APIFeatures = require('../utils/apiFeatures');

// @desc    Create a product
// @route   POST /api/products
// @access  Private/Admin
exports.createProduct = catchAsync(async (req, res, next) => {
    // Slug is auto-generated by model middleware
    const newProduct = await Product.create({
        ...req.body,
        user: req.user._id
    });

    res.status(201).json({
        status: 'success',
        data: {
            product: newProduct
        }
    });
});

// @desc    Fetch all products with filtering, sorting, pagination
// @route   GET /api/products
// @access  Public
exports.getAllProducts = catchAsync(async (req, res, next) => {
    // Basic array filtering handled by Mongo default behavior (exact match in array)
    // For "size=42", req.query.size = '42'. Mongo finds docs where sizes array contains 42.
    // Range filtering for price is handled by apiFeatures (gte, lte replacement)

    const features = new APIFeatures(Product.find(), req.query)
        .filter()
        .sort()
        .limitFields()
        .paginate();

    // Execute query
    const products = await features.query;

    // Optional: Get total count for pagination metadata (simple version)
    // const total = await Product.countDocuments(); 

    res.status(200).json({
        status: 'success',
        results: products.length,
        // page: req.query.page || 1, 
        data: {
            products
        }
    });
});

// @desc    Fetch single product by Slug or ID
// @route   GET /api/products/:slugOrId
// @access  Public
exports.getProduct = catchAsync(async (req, res, next) => {
    let query;

    // Check if the param looks like a valid Mongo ObjectId
    // A primitive check: 24 hex chars
    if (req.params.slug.match(/^[0-9a-fA-F]{24}$/)) {
        query = Product.findById(req.params.slug);
    } else {
        query = Product.findOne({ slug: req.params.slug });
    }

    const product = await query;

    if (!product) {
        return next(new AppError('No product found with that ID or Slug', 404));
    }

    res.status(200).json({
        status: 'success',
        data: {
            product
        }
    });
});

// @desc    Update a product
// @route   PUT /api/products/:id
// @access  Private/Admin
exports.updateProduct = catchAsync(async (req, res, next) => {
    const product = await Product.findById(req.params.id);

    if (!product) {
        return next(new AppError('No product found with that ID', 404));
    }

    // If name changes, slug updates automatically via save if we used save().
    // findByIdAndUpdate doesn't trigger save middleware by default unless configured,
    // but typically we want to update specific fields. 
    // If we want slug to update, we might need to manually handle it or use save().
    // Using findByIdAndUpdate is standard for REST PUT/PATCH.
    // If slug update is critical on name change, better to use find + save.

    // Let's use standard findByIdAndUpdate for efficiency unless name changed.
    // However, user requirements imply "Slug auto-generation" which might imply updates too.
    // Let's stick effectively to the requested PUT.

    // Merging existing fields with body
    Object.assign(product, req.body);

    // If we use save, it triggers the pre-save hook which re-generates slug from name.
    const updatedProduct = await product.save();

    res.status(200).json({
        status: 'success',
        data: {
            product: updatedProduct
        }
    });
});

// @desc    Delete a product (Soft Delete)
// @route   DELETE /api/products/:id
// @access  Private/Admin
exports.deleteProduct = catchAsync(async (req, res, next) => {
    const product = await Product.findById(req.params.id);

    if (!product) {
        return next(new AppError('No product found with that ID', 404));
    }

    // Soft delete with Date
    product.deletedAt = new Date();
    await product.save();

    res.status(204).json({
        status: 'success',
        data: null
    });
});
